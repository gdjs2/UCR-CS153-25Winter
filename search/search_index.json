{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CS153 - Design of Operating System - Lab Session - 25 Winter Basic Info Hi\ud83d\udc4b, welcome to the course page for CS153 Design of Operating System, Winter 2025 for UC Riverside, whose lecture is hosted by Prof. Heng Yin . The laboratory section would be hosted by me, Zhaoqi Xiao. There will be 3 individual lab assignments for this course starting from lab 1. You need to submit a short report on eLearn and a git commit on github classroom. Late Policy No slack days We will use the eLearn submission timestamp to determine the days. Please note that deadlines are end of day (11:59:59pm). If you're a few minutes late, the submission will not be considered as late. 10% penalty for every late day and the maximum penalty is 50%, so submitting is always better than not submitting. Lab Participation There will be 2 lab sessions per week, while you only need to take one which is more convenient to you. We will track the attendance in the first lab session after a new assignment is released (e.g., the lab in the next week, in which we will release lab 1). The left Q/A labs will not have attendance taken. You are free to come if you need help on your lab assignment. Index for Labs Lab 0 (Not counted for score) Supplementary Materials C language and pointers Debug for xv6 How to resolve conflict on Github? xv6 Tutorial xv6 Book What is RISC-V? Why don't we use xv6-x86?","title":"CS153 - Design of Operating System - Lab Session - 25 Winter"},{"location":"#cs153-design-of-operating-system-lab-session-25-winter","text":"","title":"CS153 - Design of Operating System - Lab Session - 25 Winter"},{"location":"#basic-info","text":"Hi\ud83d\udc4b, welcome to the course page for CS153 Design of Operating System, Winter 2025 for UC Riverside, whose lecture is hosted by Prof. Heng Yin . The laboratory section would be hosted by me, Zhaoqi Xiao. There will be 3 individual lab assignments for this course starting from lab 1. You need to submit a short report on eLearn and a git commit on github classroom.","title":"Basic Info"},{"location":"#late-policy","text":"No slack days We will use the eLearn submission timestamp to determine the days. Please note that deadlines are end of day (11:59:59pm). If you're a few minutes late, the submission will not be considered as late. 10% penalty for every late day and the maximum penalty is 50%, so submitting is always better than not submitting.","title":"Late Policy"},{"location":"#lab-participation","text":"There will be 2 lab sessions per week, while you only need to take one which is more convenient to you. We will track the attendance in the first lab session after a new assignment is released (e.g., the lab in the next week, in which we will release lab 1). The left Q/A labs will not have attendance taken. You are free to come if you need help on your lab assignment.","title":"Lab Participation"},{"location":"#index-for-labs","text":"Lab 0 (Not counted for score)","title":"Index for Labs"},{"location":"#supplementary-materials","text":"C language and pointers Debug for xv6 How to resolve conflict on Github? xv6 Tutorial xv6 Book What is RISC-V? Why don't we use xv6-x86?","title":"Supplementary Materials"},{"location":"lab-instructions/c-pointers/","text":"Introduction to C language and Pointers C language C is a little different from the high-level languages you have learned like C++, Python, Java etc., (even though C++ is derived from C in some sense). C & C++ is memory unsafe (if you don't use smart pointer or 3rd party library to manage the memory usage) as we all know. One critical reason is that, C & C++ can use pointers to manage the memory, which makes it more flexible for low-level programming and more efficient. For some historic reason, most modern OS is mostly written in C, including our xv6. Therefore, understanding C is very important for your programming in xv6. Luckily, C is quite similar to C++ and Java, which most of you have learned. For example, the variable declaration and primary operations. Therefore, I only introduce some key differences for C here. I cannot cover all things in this page. Therefore, if you have more questions, ask me or visit https://cplusplus.com for help. Structure If you have used structure struct in C++, that's good. If not, don't worry. It's just a simple version of class as you have learned in C++/Java. A structure is just a composition of different variables. For example, if you want to declare a data structure, which contains 3 integers and 1 float. struct ds { int a, b, c; float d; } Good? Traditionally, you can't declare a member function inside a structure (just like the way you do in class). Maybe some compilers support this, remember, this is not standard! Therefore, when you need to declare some data structures, use struct and no functions in it. Pointers Pointer type exists in both C & C++. Simply, it's a value, which stores an \"address\" of something. What is address? Assume you have a variable, like a . int a = 0xdeadbeef; This a should be stored in some place in the memory. We use \"address\" to find this place in the memory. We can get this address by using operator & . int a = 0xdeadbeef; int *a_ptr = &a; Here, we declare another variable a_ptr with type int * , which means this variable is used for storing the address of an int type (which is a here). You can print a_ptr just like other normal variables using format %p ( %p is standing for 'pointer', just like %d for decimal number). int a = 0xdeadbeef; int *a_ptr = &a; printf(\"a_ptr = %p\\n\", a_ptr); My result is: $ ./main a_ptr = 0x7ffe2cf0832c Here, 0x7ffe2cf0832c is an address and variable a is just stored at this location in the memory. Therefore, 0x7ffe2cf0832c can be used to point to some position in the memory, that'w why it is called 'pointer'. To use pointers accessing memory, you need another operator * . int a = 0xdeadbeef; int *a_ptr = &a; printf(\"a_ptr = %p\\n\", a_ptr); printf(\"a = 0x%x\\n\", *a_ptr); Here, we use *a_ptr to access the value stored in the memory location represented by a_ptr (which is just the variable a in this case), and the result for this piece of code in my machine is: $ ./main a_ptr = 0x7ffdc0f4e46c a = 0xdeadbeef This is just a basic introduction to what pointer is. There are a lot of materials introducing 'pointer' this important concept in the internet. When you don't know what a expression about pointer is, just take a little search on Google and you can find the result. e.g., do you know what is this type standing for? int* (*func_ptr)(int**, char*)","title":"Introduction to C language and Pointers"},{"location":"lab-instructions/c-pointers/#introduction-to-c-language-and-pointers","text":"","title":"Introduction to C language and Pointers"},{"location":"lab-instructions/c-pointers/#c-language","text":"C is a little different from the high-level languages you have learned like C++, Python, Java etc., (even though C++ is derived from C in some sense). C & C++ is memory unsafe (if you don't use smart pointer or 3rd party library to manage the memory usage) as we all know. One critical reason is that, C & C++ can use pointers to manage the memory, which makes it more flexible for low-level programming and more efficient. For some historic reason, most modern OS is mostly written in C, including our xv6. Therefore, understanding C is very important for your programming in xv6. Luckily, C is quite similar to C++ and Java, which most of you have learned. For example, the variable declaration and primary operations. Therefore, I only introduce some key differences for C here. I cannot cover all things in this page. Therefore, if you have more questions, ask me or visit https://cplusplus.com for help.","title":"C language"},{"location":"lab-instructions/c-pointers/#structure","text":"If you have used structure struct in C++, that's good. If not, don't worry. It's just a simple version of class as you have learned in C++/Java. A structure is just a composition of different variables. For example, if you want to declare a data structure, which contains 3 integers and 1 float. struct ds { int a, b, c; float d; } Good? Traditionally, you can't declare a member function inside a structure (just like the way you do in class). Maybe some compilers support this, remember, this is not standard! Therefore, when you need to declare some data structures, use struct and no functions in it.","title":"Structure"},{"location":"lab-instructions/c-pointers/#pointers","text":"Pointer type exists in both C & C++. Simply, it's a value, which stores an \"address\" of something. What is address? Assume you have a variable, like a . int a = 0xdeadbeef; This a should be stored in some place in the memory. We use \"address\" to find this place in the memory. We can get this address by using operator & . int a = 0xdeadbeef; int *a_ptr = &a; Here, we declare another variable a_ptr with type int * , which means this variable is used for storing the address of an int type (which is a here). You can print a_ptr just like other normal variables using format %p ( %p is standing for 'pointer', just like %d for decimal number). int a = 0xdeadbeef; int *a_ptr = &a; printf(\"a_ptr = %p\\n\", a_ptr); My result is: $ ./main a_ptr = 0x7ffe2cf0832c Here, 0x7ffe2cf0832c is an address and variable a is just stored at this location in the memory. Therefore, 0x7ffe2cf0832c can be used to point to some position in the memory, that'w why it is called 'pointer'. To use pointers accessing memory, you need another operator * . int a = 0xdeadbeef; int *a_ptr = &a; printf(\"a_ptr = %p\\n\", a_ptr); printf(\"a = 0x%x\\n\", *a_ptr); Here, we use *a_ptr to access the value stored in the memory location represented by a_ptr (which is just the variable a in this case), and the result for this piece of code in my machine is: $ ./main a_ptr = 0x7ffdc0f4e46c a = 0xdeadbeef This is just a basic introduction to what pointer is. There are a lot of materials introducing 'pointer' this important concept in the internet. When you don't know what a expression about pointer is, just take a little search on Google and you can find the result. e.g., do you know what is this type standing for? int* (*func_ptr)(int**, char*)","title":"Pointers"},{"location":"lab-instructions/lab0/","text":"Lab 0 Instructions Before you start You don't need to submit ANYTHING for this lab. This is a demo for you to get familiar to the github classroom. Try this step-by-step demo and push your work to see whether you can achieve full score! Accept Lab 0 Accept Lab 0 thourgh the link: https://classroom.github.com/a/tgW8fvsX . Join our classroom and link your github account with your netid. If you don't see your netid in the list, tell me! Required System A Unix-like system! It can be: Any Linux distribution (e.g., Ubuntu) macOS Windows Subsystem Linux, WSL (Click here to see how to install!). I suggest you all install Ubuntu 24.04. Because QEMU on the repository of Ubuntu 22.04 is with version 6.2, which is incompatible to current xv6. The 8.2 version QEMU in Ubuntu 24.04 works well. When you install using powershell command, change the command wsl --install to wsl --install -d ubuntu-24.04 which will change Linux distribution you install. Required Tools After you get your system set up, you should install some necessary tools for developing xv6. Run the following command in your command line (copy & paste the command just following the $ sign). If you meet errors when downloading the requirements, check whether you update your package manager's index first. For example, if you are using Ubuntu, you need use $ sudo apt update to update your index. Debian or Ubuntu $ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu Arch Linux $ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full macOS Install developer tools if you haven't: $ xcode-select --install Next, install Homebrew , a package manager for macOS if you haven't: $ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Next, install the RISC-V compiler toolchain : $ brew tap riscv-software-src/riscv $ brew install riscv-tools The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. ~/.bashrc ) to add the appropriate directory to $PATH . Finally install QEMU: $ brew install qemu Test your tools Run the following command to see whether it can give you the version number for the programs: $ qemu-system-riscv64 --version QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2) ... And at least one RISC-V version of GCC: $ riscv64-linux-gnu-gcc --version riscv64-linux-gnu-gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0 ... $ riscv64-unknown-elf-gcc --version $ riscv64-unknown-linux-gnu-gcc --version Clone your repository After you accept the lab, you will get a repository for our lab 0, which has a name lab0-*** . Clone this repo to your local machine. If you never used Github before (never set a SSH key for your account), please refer to here . Compile Get into the directory with your lab0 code. $ cd /some/path/to/xv6-riscv-lab0 Build and run xv6 $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb ... riscv64-linux-gnu-objdump -S user/_zombie > user/zombie.asm riscv64-linux-gnu-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' > user/zombie.sym mkfs/mkfs fs.img README user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 1954 total 2000 balloc: first 767 blocks have been allocated balloc: write bitmap block at sector 45 qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 xv6 kernel is booting hart 2 starting hart 1 starting init: starting sh Now, xv6-riscv has been compiled and a bash is running. If you type ls at the prompt, you should see output similar to the following: $ ls . 1 1 1024 .. 1 1 1024 README 2 2 2292 cat 2 3 34264 echo 2 4 33184 forktest 2 5 16184 grep 2 6 37520 init 2 7 33648 kill 2 8 33104 ln 2 9 32920 ls 2 10 36288 mkdir 2 11 33160 rm 2 12 33152 sh 2 13 54728 stressfs 2 14 34048 usertests 2 15 179352 grind 2 16 49400 wc 2 17 35216 zombie 2 18 32528 console 3 19 0 There are the files that mkfs includes in the initial file system; most are programs you can run. To quit qemu type Ctrl-a x (press Ctrl and a at the same time, followed by x ) Add the First User Program! Open this directory using any code editor (e.g., vscode). In the directory /user , add a file named by hello-world.c . Copy and paste the following code to the file. Remember to save it. #include \"kernel/types.h\" #include \"user/user.h\" int main() { printf(\"hello, world\\n\"); } Add one line in the file /Makefile , just after line 141 and save. ... $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_hello-world\\ Now recompile the code using make qemu . After you see init: starting sh . You can type ls to check whether there is a new program naming hello-world . If there is, type command hello-world to run this program. $ hello-world hello, world You are done with your work here! Push Your Work You now can push your work to the repository in Github Classroom. You can use the GUI of your editor (e.g., vscode) to do this, or you can use the command line. For command line: https://docs.github.com/en/repositories/working-with-files/managing-files/adding-a-file-to-a-repository#adding-a-file-to-a-repository-using-the-command-line For vscode: https://code.visualstudio.com/docs/sourcecontrol/intro-to-git#_staging-and-committing-code-changes Just focus on Section Staging and committing code changes and Section Pushing and pulling remote changes Hit: Always use make clean to clean up the binary files compiled before you commit your change. It can avoid submitting unnecessary files (usually binary and intermediate files). Basic Linux Commands cd [SOMEWHERE] : change directory to SOMEWHERE. cd / will change directory to root directoty. cd .. will change to the upper level directory. cd dir1 will change to dir1 under currect directory. ls or ls [SOMEWHERE] : ls is the same as ls . , which means list the items in currect directory. You can use a parameter to specify which directory you want to list. Basic Git Commands git clone [URL] : clone a repository to currect position. git add [FILES] : add some files for tracking. git commit -c \"CMNT HERE\" : commit the changes and append some comment. git push : push the commit(s) to the remote repository. Git related Questions How can I clone a private repository to my local machine? https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository What if there is a permission error when I try cloning a repository? https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account","title":"Lab 0 Instructions"},{"location":"lab-instructions/lab0/#lab-0-instructions","text":"","title":"Lab 0 Instructions"},{"location":"lab-instructions/lab0/#before-you-start","text":"You don't need to submit ANYTHING for this lab. This is a demo for you to get familiar to the github classroom. Try this step-by-step demo and push your work to see whether you can achieve full score!","title":"Before you start"},{"location":"lab-instructions/lab0/#accept-lab-0","text":"Accept Lab 0 thourgh the link: https://classroom.github.com/a/tgW8fvsX . Join our classroom and link your github account with your netid. If you don't see your netid in the list, tell me!","title":"Accept Lab 0"},{"location":"lab-instructions/lab0/#required-system","text":"A Unix-like system! It can be: Any Linux distribution (e.g., Ubuntu) macOS Windows Subsystem Linux, WSL (Click here to see how to install!). I suggest you all install Ubuntu 24.04. Because QEMU on the repository of Ubuntu 22.04 is with version 6.2, which is incompatible to current xv6. The 8.2 version QEMU in Ubuntu 24.04 works well. When you install using powershell command, change the command wsl --install to wsl --install -d ubuntu-24.04 which will change Linux distribution you install.","title":"Required System"},{"location":"lab-instructions/lab0/#required-tools","text":"After you get your system set up, you should install some necessary tools for developing xv6. Run the following command in your command line (copy & paste the command just following the $ sign). If you meet errors when downloading the requirements, check whether you update your package manager's index first. For example, if you are using Ubuntu, you need use $ sudo apt update to update your index.","title":"Required Tools"},{"location":"lab-instructions/lab0/#debian-or-ubuntu","text":"$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu","title":"Debian or Ubuntu"},{"location":"lab-instructions/lab0/#arch-linux","text":"$ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full","title":"Arch Linux"},{"location":"lab-instructions/lab0/#macos","text":"Install developer tools if you haven't: $ xcode-select --install Next, install Homebrew , a package manager for macOS if you haven't: $ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Next, install the RISC-V compiler toolchain : $ brew tap riscv-software-src/riscv $ brew install riscv-tools The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. ~/.bashrc ) to add the appropriate directory to $PATH . Finally install QEMU: $ brew install qemu","title":"macOS"},{"location":"lab-instructions/lab0/#test-your-tools","text":"Run the following command to see whether it can give you the version number for the programs: $ qemu-system-riscv64 --version QEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2) ... And at least one RISC-V version of GCC: $ riscv64-linux-gnu-gcc --version riscv64-linux-gnu-gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0 ... $ riscv64-unknown-elf-gcc --version $ riscv64-unknown-linux-gnu-gcc --version","title":"Test your tools"},{"location":"lab-instructions/lab0/#clone-your-repository","text":"After you accept the lab, you will get a repository for our lab 0, which has a name lab0-*** . Clone this repo to your local machine. If you never used Github before (never set a SSH key for your account), please refer to here .","title":"Clone your repository"},{"location":"lab-instructions/lab0/#compile","text":"Get into the directory with your lab0 code. $ cd /some/path/to/xv6-riscv-lab0 Build and run xv6 $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb ... riscv64-linux-gnu-objdump -S user/_zombie > user/zombie.asm riscv64-linux-gnu-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' > user/zombie.sym mkfs/mkfs fs.img README user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 1954 total 2000 balloc: first 767 blocks have been allocated balloc: write bitmap block at sector 45 qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 xv6 kernel is booting hart 2 starting hart 1 starting init: starting sh Now, xv6-riscv has been compiled and a bash is running. If you type ls at the prompt, you should see output similar to the following: $ ls . 1 1 1024 .. 1 1 1024 README 2 2 2292 cat 2 3 34264 echo 2 4 33184 forktest 2 5 16184 grep 2 6 37520 init 2 7 33648 kill 2 8 33104 ln 2 9 32920 ls 2 10 36288 mkdir 2 11 33160 rm 2 12 33152 sh 2 13 54728 stressfs 2 14 34048 usertests 2 15 179352 grind 2 16 49400 wc 2 17 35216 zombie 2 18 32528 console 3 19 0 There are the files that mkfs includes in the initial file system; most are programs you can run. To quit qemu type Ctrl-a x (press Ctrl and a at the same time, followed by x )","title":"Compile"},{"location":"lab-instructions/lab0/#add-the-first-user-program","text":"Open this directory using any code editor (e.g., vscode). In the directory /user , add a file named by hello-world.c . Copy and paste the following code to the file. Remember to save it. #include \"kernel/types.h\" #include \"user/user.h\" int main() { printf(\"hello, world\\n\"); } Add one line in the file /Makefile , just after line 141 and save. ... $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_hello-world\\ Now recompile the code using make qemu . After you see init: starting sh . You can type ls to check whether there is a new program naming hello-world . If there is, type command hello-world to run this program. $ hello-world hello, world You are done with your work here!","title":"Add the First User Program!"},{"location":"lab-instructions/lab0/#push-your-work","text":"You now can push your work to the repository in Github Classroom. You can use the GUI of your editor (e.g., vscode) to do this, or you can use the command line. For command line: https://docs.github.com/en/repositories/working-with-files/managing-files/adding-a-file-to-a-repository#adding-a-file-to-a-repository-using-the-command-line For vscode: https://code.visualstudio.com/docs/sourcecontrol/intro-to-git#_staging-and-committing-code-changes Just focus on Section Staging and committing code changes and Section Pushing and pulling remote changes Hit: Always use make clean to clean up the binary files compiled before you commit your change. It can avoid submitting unnecessary files (usually binary and intermediate files).","title":"Push Your Work"},{"location":"lab-instructions/lab0/#basic-linux-commands","text":"cd [SOMEWHERE] : change directory to SOMEWHERE. cd / will change directory to root directoty. cd .. will change to the upper level directory. cd dir1 will change to dir1 under currect directory. ls or ls [SOMEWHERE] : ls is the same as ls . , which means list the items in currect directory. You can use a parameter to specify which directory you want to list.","title":"Basic Linux Commands"},{"location":"lab-instructions/lab0/#basic-git-commands","text":"git clone [URL] : clone a repository to currect position. git add [FILES] : add some files for tracking. git commit -c \"CMNT HERE\" : commit the changes and append some comment. git push : push the commit(s) to the remote repository.","title":"Basic Git Commands"},{"location":"lab-instructions/lab0/#git-related-questions","text":"","title":"Git related Questions"},{"location":"lab-instructions/lab0/#how-can-i-clone-a-private-repository-to-my-local-machine","text":"https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository","title":"How can I clone a private repository to my local machine?"},{"location":"lab-instructions/lab0/#what-if-there-is-a-permission-error-when-i-try-cloning-a-repository","text":"https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account","title":"What if there is a permission error when I try cloning a repository?"},{"location":"lab-instructions/lab1/","text":"Lab 1 - System Call Background What is system call? A system call is a way for programs to interact with the operating system. It provides an interface between a process and the operating system, allowing the process to request high-privilege services such as file operatios, process control and communication. Because it involves two parties - the user program (low privilege) and the operating system (high privilege), it is bound to have a transition of privileges. How does system call work? You can call a system call (e.g., exit(), which is used for terminating current program) in a user space program (like in our hello-world.c program). Let's just use our hello-world program and change it a little bit. // hello-world.c in /user/ #include \"kernel/types.h\" #include \"user/user.h\" int main(int argc, char **argv) { printf(\"Hello, world!\\n\"); exit(0); printf(\"?.? Dead code ?.?\\n\"); } Also, we need to add a line in the Makefile . This modification adds a user space program, making program make know that it should compile the program hello-world.c under /user/ . $U stands for /user/ directory. ... line 138 $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_hello-world\\ Let's compile this file and see what will happen. $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S ... xv6 kernel is booting hart 2 starting hart 1 starting init: starting sh $ Then use ls command listing all available programs in user space. $ ls . 1 1 1024 .. 1 1 1024 README 2 2 2292 cat 2 3 34256 echo 2 4 33184 forktest 2 5 16168 grep 2 6 37520 init 2 7 33640 kill 2 8 33096 ln 2 9 32912 ls 2 10 36280 mkdir 2 11 33152 rm 2 12 33144 sh 2 13 54720 stressfs 2 14 34040 usertests 2 15 179344 grind 2 16 49392 wc 2 17 35216 zombie 2 18 32520 hello-world 2 19 32656 console 3 20 0 We can check there is a hello-world program. Then we can execute it by: $ hello-world Hello, world! What happened? The code after exit(0) is just ignored. The reason for this is the program just exits at exit(0) and of course the left code wouldn't be executed forever. Ok, now let's just see what will happend in the call of exit(0) . The definition of exit() function is in the file /user/user.h . ... // system calls int fork(void); int exit(int) __attribute__((noreturn)); int wait(int*); ... We can see that its return value is an integer and it receives an inteter as its parameter. The __attribute__((noreturn)) part is a compiler annotation telling the compilers (gcc & clang both support this) this function wouldn't return. However, this is just the definition of this function. In C/C++, we know that a definition of function isn't executable. Therefore, where is the implementation of this function? The secret is in the file /user/usys.pl . This file is a Perl program. Perl is just like Python, which is also an interpreter-based language. This usys.pl would generate the 'trigger' for function calls. This Perl script might be dense, but once you compile xv6 using make qemu , you can find the file generated by it, which is /user/usys.S . # generated by usys.pl - do not edit #include \"kernel/syscall.h\" ... .global exit exit: li a7, SYS_exit ecall ret ... Generally, this /user/usys.S , which is an assembly code for RISC-V, has done two things-including /kernel/syscall.h and making many global symbols (declared by .global ** , e.g., .global exit defines a symbol exit ) with corresponding functions' assembly code. Let's just use the example of exit() . .global exit # declare a symbol, you can image it as a variable exit: # this is a tag, meaning symbol exit points to here li a7, SYS_exit # load immediate value, SYS_exit, into register a7 ecall # system call instruction in RISC-V ret # return There are still several questions in this small piece of assembly code. Where is the immediate value SYS_exit ? Where does the program go after we use ecall function? For the first question, let's get back to the first thing usys.S has done-the included file /kernel/syscall.h // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 ... See? All the immediate values are define here and included into the assembly code by #include \"kernel/syscall.h\" . For the second question, it's a little complicated. If you want to learn more, you can refer to xv6 book chapter 4.3. In short, ecall instruction in user mode (now we are running hello-world , which is a userspace program) will trap the execution into uservec() function in trampoline.S and further get into usertrap() function in /kernel/trap.c . So far, the transition between user space and kernel space has done. The CPU's privilege mode has been set to 1, which is supervisor mode (S-mode). However, the memory page table hasn't been set to kernel's (you can think about the reason after you learn more). void usertrap(void) { ... intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ ... } Following function usertrap() in /kernel/trap.c , it finally goes to syscall(void) function in /kernel/syscall.c . This function is easy to understand now (T.T compared to previous assembly code). void syscall(void) { int num; struct proc *p = myproc(); num = p->trapframe->a7; if(num > 0 && num < NELEM(syscalls) && syscalls[num]) { // Use num to lookup the system call function for num, call it, // and store its return value in p->trapframe->a0 p->trapframe->a0 = syscalls[num](); } else { printf(\"%d %s: unknown sys call %d\\n\", p->pid, p->name, num); p->trapframe->a0 = -1; } } At line 137, we got the number stored in user program's register a7 . Feel familiar? Yes! It was stored a little before in the function exit() of /user/usys.S . .global exit # declare a symbol, you can image it as a variable exit: # this is a tag, meaning symbol exit points to here li a7, SYS_exit # load immediate value, SYS_exit, into register a7 HERE!!!!!!!!! ecall # system call instruction in RISC-V ret # return SYS_exit , which is just the SYSTEM CALL NUMBER, was stored in user program and then read by kernel here. Magic, right? Then there is a if statement judging whetehr the syscall number is greater than 0 and less than the number of elements in syscalls table. OK, now let's take a look at syscalls table. (It's from line 107 - 129) // An array mapping syscall numbers from syscall.h // to the function that handles the system call. static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, ... }; Here, this type might be hard to understand. To be simple, it's an array and each element in this array is a function pointer . The functions should have type of uint64 function(void) , which means these functions receive no arguments and return a single unsigned 64-bits integer. Then, what's the values in this array? Let's use a simple C program example. #include <stdio.h> int main() { int arr[] = { [0] 10, [1] 100, [3] 1000, [5] 0xdeadbeef }; int len = sizeof(arr) / sizeof(int); printf(\"Length of arr: %d\\n\", len); for (int i = 0; i < len; ++i) { printf(\"arr[%d] = %d\\n\", i, arr[i]); } } You can simply copy this code and run it on your computer. The result should be: $ ./main Length of arr: 6 arr[0] = 10 arr[1] = 100 arr[2] = 0 arr[3] = 1000 arr[4] = 0 arr[5] = -559038737 Now, it's pretty obvious! The numbers in [] is the index and the number after each index is it's corresponding value. For example, we stored 10 to position 0 and 1000 to position 3. Note: this semantic isn't officially supported by C++, which means even it's a valid grammer in C, it might be failed in compilation for some C++ compilers. Now, let's come back to the syscalls array. There are some functions and each function is stored at the position of its system call number. For example, the syscall number for exit() is 2, which you can find in /kernel/syscall.h . Therefore syscalls[2] will be a function pointer pointing to sys_exit() . We are close! Then, what is sys_exit() ? It's in file /kernel/sysproc.c and you can find it's pretty short. uint64 sys_exit(void) { int n; argint(0, &n); exit(n); return 0; // not reached } Do you still remember what the definition of exit() syscall is in the user space? It's int exit(int) __attribute__((noreturn)) . It has one argument and one return value, both are of integer type. But now, when coming to sys_exit() , the return value is still there, but where is our argument? Here, we need to explain why we cannot directly pass our parameters using our normal way (i.e., sys_exit(int) ). It is because when we stores the function pointers to syscalls[] , all functions should have the same type. However, different system call has their own type of parameters. Hence, for a more convenient call of system calls of different arguments type, we make all of them with non-argument and let them parse their own arguments in sys_**() . (No matter you understand or not, I'm confused now :( ) In the first line of the function, it prepare a value n for the argument passed for exit() syscall. argint(0, &n) fetches the first value in the calling argument and stores it into variable n . Then it execute exit(n) . (Can it be the last function containing exit ????) OK, now let's see the very LAST exit() function. It's in the file /kernel/proc.c . // Exit the current process. Does not return. // An exited process remains in the zombie state // until its parent calls wait(). void exit(int status) { struct proc *p = myproc(); if(p == initproc) panic(\"init exiting\"); // Close all open files. for(int fd = 0; fd < NOFILE; fd++){ if(p->ofile[fd]){ struct file *f = p->ofile[fd]; fileclose(f); p->ofile[fd] = 0; } } begin_op(); iput(p->cwd); end_op(); p->cwd = 0; acquire(&wait_lock); // Give any children to init. reparent(p); // Parent might be sleeping in wait(). wakeup(p->parent); acquire(&p->lock); p->xstate = status; p->state = ZOMBIE; release(&wait_lock); // Jump into the scheduler, never to return. sched(); panic(\"zombie exit\"); } This function is well documented so I wouldn't write a lot to explain it. But we can see, in the end, it calls sched() which is the process scheduler. When it gets into the scheduler, the other ready processes will be run by the scheduler. So, question is, where is our argument, the status for exit? It is stored in p->xstate , which is used for storing the exit status specially. I wrote all of this by my own. Hopefully it can help you understand how function call works. T_T Your Task There is only one task for you, easy, not much work to do and only a few dozen lines of code could finish it. Now, you may (or may not) know that, fork() will create a child process. Now, suppose you have one parent process with PID=1 and two child processes of him, PID=2 and PID=3. What if your parent want to wait for these two child processes finishing their work? You can use wait() syscall. wait() will return once there is one child process exits (in another word, becomes zombie as we saw in exit() ) after cleaning up all the memory for the child process. Easy to understand, right? Your task, is adding another system call with user space definition int waitpid(int *status, int pid, int option); Explanation for parameters: int *status , this is a pointer, the status of exited program should be stored into this location, just like wait(int*) . int pid , instead of waiting for arbitrary child process terminating, waitpid() should only wait for specific child with pid . There are some special values for it: If pid <= 0, which means it's an invalid pid in xv6 (xv6 has a pid > 0), your function should work as wait(int*) , which means it will return whenever a child process exits. If pid > 0, but the process with pid isn't","title":"Lab 1 - System Call"},{"location":"lab-instructions/lab1/#lab-1-system-call","text":"","title":"Lab 1 - System Call"},{"location":"lab-instructions/lab1/#background","text":"","title":"Background"},{"location":"lab-instructions/lab1/#what-is-system-call","text":"A system call is a way for programs to interact with the operating system. It provides an interface between a process and the operating system, allowing the process to request high-privilege services such as file operatios, process control and communication. Because it involves two parties - the user program (low privilege) and the operating system (high privilege), it is bound to have a transition of privileges.","title":"What is system call?"},{"location":"lab-instructions/lab1/#how-does-system-call-work","text":"You can call a system call (e.g., exit(), which is used for terminating current program) in a user space program (like in our hello-world.c program). Let's just use our hello-world program and change it a little bit. // hello-world.c in /user/ #include \"kernel/types.h\" #include \"user/user.h\" int main(int argc, char **argv) { printf(\"Hello, world!\\n\"); exit(0); printf(\"?.? Dead code ?.?\\n\"); } Also, we need to add a line in the Makefile . This modification adds a user space program, making program make know that it should compile the program hello-world.c under /user/ . $U stands for /user/ directory. ... line 138 $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_hello-world\\ Let's compile this file and see what will happen. $ make qemu riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S ... xv6 kernel is booting hart 2 starting hart 1 starting init: starting sh $ Then use ls command listing all available programs in user space. $ ls . 1 1 1024 .. 1 1 1024 README 2 2 2292 cat 2 3 34256 echo 2 4 33184 forktest 2 5 16168 grep 2 6 37520 init 2 7 33640 kill 2 8 33096 ln 2 9 32912 ls 2 10 36280 mkdir 2 11 33152 rm 2 12 33144 sh 2 13 54720 stressfs 2 14 34040 usertests 2 15 179344 grind 2 16 49392 wc 2 17 35216 zombie 2 18 32520 hello-world 2 19 32656 console 3 20 0 We can check there is a hello-world program. Then we can execute it by: $ hello-world Hello, world! What happened? The code after exit(0) is just ignored. The reason for this is the program just exits at exit(0) and of course the left code wouldn't be executed forever. Ok, now let's just see what will happend in the call of exit(0) . The definition of exit() function is in the file /user/user.h . ... // system calls int fork(void); int exit(int) __attribute__((noreturn)); int wait(int*); ... We can see that its return value is an integer and it receives an inteter as its parameter. The __attribute__((noreturn)) part is a compiler annotation telling the compilers (gcc & clang both support this) this function wouldn't return. However, this is just the definition of this function. In C/C++, we know that a definition of function isn't executable. Therefore, where is the implementation of this function? The secret is in the file /user/usys.pl . This file is a Perl program. Perl is just like Python, which is also an interpreter-based language. This usys.pl would generate the 'trigger' for function calls. This Perl script might be dense, but once you compile xv6 using make qemu , you can find the file generated by it, which is /user/usys.S . # generated by usys.pl - do not edit #include \"kernel/syscall.h\" ... .global exit exit: li a7, SYS_exit ecall ret ... Generally, this /user/usys.S , which is an assembly code for RISC-V, has done two things-including /kernel/syscall.h and making many global symbols (declared by .global ** , e.g., .global exit defines a symbol exit ) with corresponding functions' assembly code. Let's just use the example of exit() . .global exit # declare a symbol, you can image it as a variable exit: # this is a tag, meaning symbol exit points to here li a7, SYS_exit # load immediate value, SYS_exit, into register a7 ecall # system call instruction in RISC-V ret # return There are still several questions in this small piece of assembly code. Where is the immediate value SYS_exit ? Where does the program go after we use ecall function? For the first question, let's get back to the first thing usys.S has done-the included file /kernel/syscall.h // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 ... See? All the immediate values are define here and included into the assembly code by #include \"kernel/syscall.h\" . For the second question, it's a little complicated. If you want to learn more, you can refer to xv6 book chapter 4.3. In short, ecall instruction in user mode (now we are running hello-world , which is a userspace program) will trap the execution into uservec() function in trampoline.S and further get into usertrap() function in /kernel/trap.c . So far, the transition between user space and kernel space has done. The CPU's privilege mode has been set to 1, which is supervisor mode (S-mode). However, the memory page table hasn't been set to kernel's (you can think about the reason after you learn more). void usertrap(void) { ... intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ ... } Following function usertrap() in /kernel/trap.c , it finally goes to syscall(void) function in /kernel/syscall.c . This function is easy to understand now (T.T compared to previous assembly code). void syscall(void) { int num; struct proc *p = myproc(); num = p->trapframe->a7; if(num > 0 && num < NELEM(syscalls) && syscalls[num]) { // Use num to lookup the system call function for num, call it, // and store its return value in p->trapframe->a0 p->trapframe->a0 = syscalls[num](); } else { printf(\"%d %s: unknown sys call %d\\n\", p->pid, p->name, num); p->trapframe->a0 = -1; } } At line 137, we got the number stored in user program's register a7 . Feel familiar? Yes! It was stored a little before in the function exit() of /user/usys.S . .global exit # declare a symbol, you can image it as a variable exit: # this is a tag, meaning symbol exit points to here li a7, SYS_exit # load immediate value, SYS_exit, into register a7 HERE!!!!!!!!! ecall # system call instruction in RISC-V ret # return SYS_exit , which is just the SYSTEM CALL NUMBER, was stored in user program and then read by kernel here. Magic, right? Then there is a if statement judging whetehr the syscall number is greater than 0 and less than the number of elements in syscalls table. OK, now let's take a look at syscalls table. (It's from line 107 - 129) // An array mapping syscall numbers from syscall.h // to the function that handles the system call. static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, ... }; Here, this type might be hard to understand. To be simple, it's an array and each element in this array is a function pointer . The functions should have type of uint64 function(void) , which means these functions receive no arguments and return a single unsigned 64-bits integer. Then, what's the values in this array? Let's use a simple C program example. #include <stdio.h> int main() { int arr[] = { [0] 10, [1] 100, [3] 1000, [5] 0xdeadbeef }; int len = sizeof(arr) / sizeof(int); printf(\"Length of arr: %d\\n\", len); for (int i = 0; i < len; ++i) { printf(\"arr[%d] = %d\\n\", i, arr[i]); } } You can simply copy this code and run it on your computer. The result should be: $ ./main Length of arr: 6 arr[0] = 10 arr[1] = 100 arr[2] = 0 arr[3] = 1000 arr[4] = 0 arr[5] = -559038737 Now, it's pretty obvious! The numbers in [] is the index and the number after each index is it's corresponding value. For example, we stored 10 to position 0 and 1000 to position 3. Note: this semantic isn't officially supported by C++, which means even it's a valid grammer in C, it might be failed in compilation for some C++ compilers. Now, let's come back to the syscalls array. There are some functions and each function is stored at the position of its system call number. For example, the syscall number for exit() is 2, which you can find in /kernel/syscall.h . Therefore syscalls[2] will be a function pointer pointing to sys_exit() . We are close! Then, what is sys_exit() ? It's in file /kernel/sysproc.c and you can find it's pretty short. uint64 sys_exit(void) { int n; argint(0, &n); exit(n); return 0; // not reached } Do you still remember what the definition of exit() syscall is in the user space? It's int exit(int) __attribute__((noreturn)) . It has one argument and one return value, both are of integer type. But now, when coming to sys_exit() , the return value is still there, but where is our argument? Here, we need to explain why we cannot directly pass our parameters using our normal way (i.e., sys_exit(int) ). It is because when we stores the function pointers to syscalls[] , all functions should have the same type. However, different system call has their own type of parameters. Hence, for a more convenient call of system calls of different arguments type, we make all of them with non-argument and let them parse their own arguments in sys_**() . (No matter you understand or not, I'm confused now :( ) In the first line of the function, it prepare a value n for the argument passed for exit() syscall. argint(0, &n) fetches the first value in the calling argument and stores it into variable n . Then it execute exit(n) . (Can it be the last function containing exit ????) OK, now let's see the very LAST exit() function. It's in the file /kernel/proc.c . // Exit the current process. Does not return. // An exited process remains in the zombie state // until its parent calls wait(). void exit(int status) { struct proc *p = myproc(); if(p == initproc) panic(\"init exiting\"); // Close all open files. for(int fd = 0; fd < NOFILE; fd++){ if(p->ofile[fd]){ struct file *f = p->ofile[fd]; fileclose(f); p->ofile[fd] = 0; } } begin_op(); iput(p->cwd); end_op(); p->cwd = 0; acquire(&wait_lock); // Give any children to init. reparent(p); // Parent might be sleeping in wait(). wakeup(p->parent); acquire(&p->lock); p->xstate = status; p->state = ZOMBIE; release(&wait_lock); // Jump into the scheduler, never to return. sched(); panic(\"zombie exit\"); } This function is well documented so I wouldn't write a lot to explain it. But we can see, in the end, it calls sched() which is the process scheduler. When it gets into the scheduler, the other ready processes will be run by the scheduler. So, question is, where is our argument, the status for exit? It is stored in p->xstate , which is used for storing the exit status specially. I wrote all of this by my own. Hopefully it can help you understand how function call works. T_T","title":"How does system call work?"},{"location":"lab-instructions/lab1/#your-task","text":"There is only one task for you, easy, not much work to do and only a few dozen lines of code could finish it. Now, you may (or may not) know that, fork() will create a child process. Now, suppose you have one parent process with PID=1 and two child processes of him, PID=2 and PID=3. What if your parent want to wait for these two child processes finishing their work? You can use wait() syscall. wait() will return once there is one child process exits (in another word, becomes zombie as we saw in exit() ) after cleaning up all the memory for the child process. Easy to understand, right? Your task, is adding another system call with user space definition int waitpid(int *status, int pid, int option); Explanation for parameters: int *status , this is a pointer, the status of exited program should be stored into this location, just like wait(int*) . int pid , instead of waiting for arbitrary child process terminating, waitpid() should only wait for specific child with pid . There are some special values for it: If pid <= 0, which means it's an invalid pid in xv6 (xv6 has a pid > 0), your function should work as wait(int*) , which means it will return whenever a child process exits. If pid > 0, but the process with pid isn't","title":"Your Task"}]}