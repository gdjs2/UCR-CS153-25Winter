{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CS153 - Design of Operating System - Lab Session - 25 Winter","text":""},{"location":"#basic-info","title":"Basic Info","text":"<p>Hi\ud83d\udc4b, welcome to the course page for CS153 Design of Operating System, Winter 2025 for UC Riverside, whose lecture is hosted by Prof. Heng Yin. The laboratory section would be hosted by me, Zhaoqi Xiao. </p> <p>There will be 3 individual lab assignments for this course starting from lab 1. You need to submit a short report on eLearn and a git commit on github classroom. </p>"},{"location":"#late-policy","title":"Late Policy","text":"<ul> <li>No slack days</li> <li>We will use the eLearn submission timestamp to determine the days. Please note that deadlines are end of day (11:59:59pm). If you're a few minutes late, the submission will not be considered as late.</li> <li>10% penalty for every late day and the maximum penalty is 50%, so submitting is always better than not submitting.</li> </ul>"},{"location":"#lab-participation","title":"Lab Participation","text":"<p>There will be 2 lab sessions per week, while you only need to take one which is more convenient to you. We will track the attendance in the first lab session after a new assignment is released (e.g., the lab in the next week, in which we will release lab 1). </p> <p>The left Q/A labs will not have attendance taken. You are free to come if you need help on your lab assignment. </p>"},{"location":"#index-for-labs","title":"Index for Labs","text":"<ol> <li>Lab 0 (Not counted for score)</li> <li>Lab 1</li> </ol>"},{"location":"#supplementary-materials","title":"Supplementary Materials","text":"<ul> <li>C language and pointers</li> <li>Debug for xv6</li> <li>How to resolve conflict on Github?</li> <li>xv6 Tutorial</li> <li>xv6 Book</li> <li>What is RISC-V?</li> <li>Why don't we use xv6-x86?</li> </ul>"},{"location":"lab-instructions/c-pointers/","title":"Introduction to C language and Pointers","text":""},{"location":"lab-instructions/c-pointers/#c-language","title":"C language","text":"<p>C is a little different from the high-level languages you have learned like C++, Python, Java etc., (even though C++ is derived from C in some sense). C &amp; C++ is memory unsafe (if you don't use smart pointer or 3rd party library to manage the memory usage) as we all know. One critical reason is that, C &amp; C++ can use pointers to manage the memory, which makes it more flexible for low-level programming and more efficient. </p> <p>For some historic reason, most modern OS is mostly written in C, including our xv6. Therefore, understanding C is very important for your programming in xv6.</p> <p>Luckily, C is quite similar to C++ and Java, which most of you have learned. For example, the variable declaration and primary operations. Therefore, I only introduce some key differences for C here. </p> <p>I cannot cover all things in this page. Therefore, if you have more questions, ask me or visit https://cplusplus.com for help. </p>"},{"location":"lab-instructions/c-pointers/#structure","title":"Structure","text":"<p>If you have used structure <code>struct</code> in C++, that's good. If not, don't worry. It's just a simple version of <code>class</code> as you have learned in C++/Java. A structure is just a composition of different variables. </p> <p>For example, if you want to declare a data structure, which contains 3 integers and 1 float.</p> <pre><code>struct ds {\n    int a, b, c;\n    float d;\n}\n</code></pre> <p>Good?</p> <p>Traditionally, you can't declare a member function inside a structure (just like the way you do in class). Maybe some compilers support this, remember, this is not standard!</p> <p>Therefore, when you need to declare some data structures, use <code>struct</code> and no functions in it. </p>"},{"location":"lab-instructions/c-pointers/#pointers","title":"Pointers","text":"<p>Pointer type exists in both C &amp; C++. Simply, it's a value, which stores an \"address\" of something. </p> <p>What is address? Assume you have a variable, like <code>a</code>.</p> <pre><code>int a = 0xdeadbeef;\n</code></pre> <p>This <code>a</code> should be stored in some place in the memory. We use \"address\" to find this place in the memory. We can get this address by using operator <code>&amp;</code>. </p> <pre><code>int a = 0xdeadbeef;\n\nint *a_ptr = &amp;a;\n</code></pre> <p>Here, we declare another variable <code>a_ptr</code> with type <code>int *</code>, which means this variable is used for storing the address of an <code>int</code> type (which is <code>a</code> here). </p> <p>You can print <code>a_ptr</code> just like other normal variables using format <code>%p</code> (<code>%p</code> is standing for 'pointer', just like <code>%d</code> for decimal number). </p> <pre><code>int a = 0xdeadbeef;\nint *a_ptr = &amp;a;\nprintf(\"a_ptr = %p\\n\", a_ptr);\n</code></pre> <p>My result is: <pre><code>$ ./main\na_ptr = 0x7ffe2cf0832c\n</code></pre></p> <p>Here, <code>0x7ffe2cf0832c</code> is an address and variable <code>a</code> is just stored at this location in the memory. Therefore, <code>0x7ffe2cf0832c</code> can be used to <code>point</code> to some position in the memory, that'w why it is called 'pointer'. </p> <p>To use pointers accessing memory, you need another operator <code>*</code>. <pre><code>int a = 0xdeadbeef;\nint *a_ptr = &amp;a;\nprintf(\"a_ptr = %p\\n\", a_ptr);\nprintf(\"a = 0x%x\\n\", *a_ptr);\n</code></pre></p> <p>Here, we use <code>*a_ptr</code> to access the value stored in the memory location represented by <code>a_ptr</code> (which is just the variable <code>a</code> in this case), and the result for this piece of code in my machine is:</p> <pre><code>$ ./main            \na_ptr = 0x7ffdc0f4e46c\na = 0xdeadbeef\n</code></pre> <p>This is just a basic introduction to what pointer is. There are a lot of materials introducing 'pointer' this important concept in the internet. When you don't know what a expression about pointer is, just take a little search on Google and you can find the result.</p> <p>e.g., do you know what is this type standing for? <pre><code>int* (*func_ptr)(int**, char*)\n</code></pre></p>"},{"location":"lab-instructions/lab0/","title":"Lab 0 Instructions","text":""},{"location":"lab-instructions/lab0/#before-you-start","title":"Before you start","text":"<ol> <li>You don't need to submit ANYTHING for this lab.</li> <li>This is a demo for you to get familiar to the github classroom.</li> <li>Try this step-by-step demo and push your work to see whether you can achieve full score!</li> </ol>"},{"location":"lab-instructions/lab0/#accept-lab-0","title":"Accept Lab 0","text":"<p>Accept Lab 0 thourgh the link: https://classroom.github.com/a/tgW8fvsX. Join our classroom and link your github account with your netid. If you don't see your netid in the list, tell me!</p>"},{"location":"lab-instructions/lab0/#required-system","title":"Required System","text":"<p>A Unix-like system! It can be:</p> <ol> <li>Any Linux distribution (e.g., Ubuntu)</li> <li>macOS</li> <li>Windows Subsystem Linux, WSL (Click here to see how to install!). I suggest you all install Ubuntu 24.04. Because QEMU on the repository of Ubuntu 22.04 is with version 6.2, which is incompatible to current xv6. The 8.2 version QEMU in Ubuntu 24.04 works well. </li> </ol> <p>When you install using powershell command, change the command <code>wsl --install</code> to <code>wsl --install -d ubuntu-24.04</code> which will change Linux distribution you install. </p>"},{"location":"lab-instructions/lab0/#required-tools","title":"Required Tools","text":"<p>After you get your system set up, you should install some necessary tools for developing xv6. Run the following command in your command line (copy &amp; paste the command just following the $ sign).</p> <p>If you meet errors when downloading the requirements, check whether you update your package manager's index first. For example, if you are using Ubuntu, you need use <code>$ sudo apt update</code> to update your index.</p>"},{"location":"lab-instructions/lab0/#debian-or-ubuntu","title":"Debian or Ubuntu","text":"<pre><code>$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu \n</code></pre>"},{"location":"lab-instructions/lab0/#arch-linux","title":"Arch Linux","text":"<pre><code>$ sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full\n</code></pre>"},{"location":"lab-instructions/lab0/#macos","title":"macOS","text":"<p>Install developer tools if you haven't: <pre><code>$ xcode-select --install\n</code></pre></p> <p>Next, install Homebrew, a package manager for macOS if you haven't: <pre><code>$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> <p>Next, install the RISC-V compiler toolchain: <pre><code>$ brew tap riscv-software-src/riscv\n$ brew install riscv-tools\n</code></pre></p> <p>The brew formula may not link into /usr/local. You will need to update your shell's rc file (e.g. ~/.bashrc) to add the appropriate directory to $PATH.</p> <p>Finally install QEMU: <pre><code>$ brew install qemu\n</code></pre></p>"},{"location":"lab-instructions/lab0/#test-your-tools","title":"Test your tools","text":"<p>Run the following command to see whether it can give you the version number for the programs: <pre><code>$ qemu-system-riscv64 --version\nQEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1.2)\n...\n</code></pre></p> <p>And at least one RISC-V version of GCC: <pre><code>$ riscv64-linux-gnu-gcc --version\nriscv64-linux-gnu-gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0\n...\n</code></pre> <pre><code>$ riscv64-unknown-elf-gcc --version\n</code></pre> <pre><code>$ riscv64-unknown-linux-gnu-gcc --version\n</code></pre></p>"},{"location":"lab-instructions/lab0/#clone-your-repository","title":"Clone your repository","text":"<p>After you accept the lab, you will get a repository for our lab 0, which has a name <code>lab0-***</code>. Clone this repo to your local machine. If you never used Github before (never set a SSH key for your account), please refer to here. </p>"},{"location":"lab-instructions/lab0/#compile","title":"Compile","text":"<p>Get into the directory with your lab0 code.</p> <pre><code>$ cd /some/path/to/xv6-riscv-lab0\n</code></pre> <p>Build and run xv6 <pre><code>$ make qemu\nriscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S\nriscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb\n...\nriscv64-linux-gnu-objdump -S user/_zombie &gt; user/zombie.asm\nriscv64-linux-gnu-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; user/zombie.sym\nmkfs/mkfs fs.img README user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie \nnmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 1954 total 2000\nballoc: first 767 blocks have been allocated\nballoc: write bitmap block at sector 45\nqemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -global virtio-mmio.force-legacy=false -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0\n\nxv6 kernel is booting\n\nhart 2 starting\nhart 1 starting\ninit: starting sh\n</code></pre></p> <p>Now, xv6-riscv has been compiled and a bash is running. If you type <code>ls</code> at the prompt, you should see output similar to the following: <pre><code>$ ls\n.              1 1 1024\n..             1 1 1024\nREADME         2 2 2292\ncat            2 3 34264\necho           2 4 33184\nforktest       2 5 16184\ngrep           2 6 37520\ninit           2 7 33648\nkill           2 8 33104\nln             2 9 32920\nls             2 10 36288\nmkdir          2 11 33160\nrm             2 12 33152\nsh             2 13 54728\nstressfs       2 14 34048\nusertests      2 15 179352\ngrind          2 16 49400\nwc             2 17 35216\nzombie         2 18 32528\nconsole        3 19 0\n</code></pre></p> <p>There are the files that mkfs includes in the initial file system; most are programs you can run. </p> <p>To quit qemu type <code>Ctrl-a x</code> (press <code>Ctrl</code> and <code>a</code> at the same time, followed by <code>x</code>)</p>"},{"location":"lab-instructions/lab0/#add-the-first-user-program","title":"Add the First User Program!","text":"<p>Open this directory using any code editor (e.g., vscode). In the directory <code>/user</code>, add a file named by <code>hello-world.c</code>. </p> <p>Copy and paste the following code to the file. Remember to save it.</p> <pre><code>#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main() {\n    printf(\"hello, world\\n\");\n}\n</code></pre> <p>Add one line in the file <code>/Makefile</code>, just after line 141 and save. </p> <pre><code>...\n    $U/_grind\\\n    $U/_wc\\\n    $U/_zombie\\\n    $U/_hello-world\\\n</code></pre> <p>Now recompile the code using <code>make qemu</code>. After you see <code>init: starting sh</code>. You can type <code>ls</code> to check whether there is a new program naming <code>hello-world</code>. If there is, type command <code>hello-world</code> to run this program. </p> <pre><code>$ hello-world\nhello, world\n</code></pre> <p>You are done with your work here!</p>"},{"location":"lab-instructions/lab0/#push-your-work","title":"Push Your Work","text":"<p>You now can push your work to the repository in Github Classroom. You can use the GUI of your editor (e.g., vscode) to do this, or you can use the command line. </p> <p>For command line: https://docs.github.com/en/repositories/working-with-files/managing-files/adding-a-file-to-a-repository#adding-a-file-to-a-repository-using-the-command-line</p> <p>For vscode: https://code.visualstudio.com/docs/sourcecontrol/intro-to-git#_staging-and-committing-code-changes</p> <p>Just focus on Section Staging and committing code changes and Section Pushing and pulling remote changes</p> <p>Hit: Always use <code>make clean</code> to clean up the binary files compiled before you commit your change. It can avoid submitting unnecessary files (usually binary and intermediate files). </p>"},{"location":"lab-instructions/lab0/#basic-linux-commands","title":"Basic Linux Commands","text":"<ol> <li><code>cd [SOMEWHERE]</code>: change directory to SOMEWHERE. <code>cd /</code> will change directory to root directoty. <code>cd ..</code> will change to the upper level directory. <code>cd dir1</code> will change to <code>dir1</code> under currect directory.</li> <li><code>ls</code> or <code>ls [SOMEWHERE]</code>: <code>ls</code> is the same as <code>ls .</code>, which means list the items in currect directory. You can use a parameter to specify which directory you want to list.</li> </ol>"},{"location":"lab-instructions/lab0/#basic-git-commands","title":"Basic Git Commands","text":"<ol> <li><code>git clone [URL]</code>: clone a repository to currect position. </li> <li><code>git add [FILES]</code>: add some files for tracking.</li> <li><code>git commit -c \"CMNT HERE\"</code>: commit the changes and append some comment.</li> <li><code>git push</code>: push the commit(s) to the remote repository.</li> </ol>"},{"location":"lab-instructions/lab0/#git-related-questions","title":"Git related Questions","text":""},{"location":"lab-instructions/lab0/#how-can-i-clone-a-private-repository-to-my-local-machine","title":"How can I clone a private repository to my local machine?","text":"<p>https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository</p>"},{"location":"lab-instructions/lab0/#what-if-there-is-a-permission-error-when-i-try-cloning-a-repository","title":"What if there is a permission error when I try cloning a repository?","text":"<p>https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account</p>"},{"location":"lab-instructions/lab1/","title":"Lab 1 - System Call","text":""},{"location":"lab-instructions/lab1/#accept-your-assignment","title":"Accept Your Assignment","text":"<p>https://classroom.github.com/a/c8VO7Hjn</p> <p>Due: Sunday, Feb 2nd, 2025, 23:59, PST</p>"},{"location":"lab-instructions/lab1/#background","title":"Background","text":""},{"location":"lab-instructions/lab1/#what-is-system-call","title":"What is system call?","text":"<p>A system call is a way for programs to interact with the operating system. It provides an interface between a process and the operating system, allowing the process to request high-privilege services such as file operatios, process control and communication. </p> <p>Because it involves two parties - the user program (low privilege) and the operating system (high privilege), it is bound to have a transition of privileges. </p>"},{"location":"lab-instructions/lab1/#how-does-system-call-work","title":"How does system call work?","text":"<p>You can call a system call (e.g., exit(), which is used for terminating current program) in a user space program (like in our hello-world.c program). Let's just use our hello-world program and change it a little bit.</p> <pre><code>// hello-world.c in /user/\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint main(int argc, char **argv) {\n    printf(\"Hello, world!\\n\");\n    exit(0);\n    printf(\"?.? Dead code ?.?\\n\");\n}\n</code></pre> <p>Also, we need to add a line in the <code>Makefile</code>. This modification adds a user space program, making program <code>make</code> know that it should compile the program <code>hello-world.c</code> under <code>/user/</code>. <code>$U</code> stands for <code>/user/</code> directory. </p> <p>What is user space program and what is kernel space program? If you take a look at the codebase of xv6, you may find there are two major directories, <code>/user/</code> and <code>/kernel/</code>. All the things in <code>/kernel</code> directory is kernel space program/code and the so for <code>/user</code>. However, there are much more different things between them. You can learn more from wiki</p> <pre><code>... line 138\n    $U/_grind\\\n    $U/_wc\\\n    $U/_zombie\\\n    $U/_hello-world\\\n</code></pre> <p>Let's compile this file and see what will happen. </p> <pre><code>$ make qemu\nriscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S\n...\nxv6 kernel is booting\n\nhart 2 starting\nhart 1 starting\ninit: starting sh\n$ \n</code></pre> <p>Then use <code>ls</code> command listing all available programs in user space. </p> <pre><code>$ ls\n.              1 1 1024\n..             1 1 1024\nREADME         2 2 2292\ncat            2 3 34256\necho           2 4 33184\nforktest       2 5 16168\ngrep           2 6 37520\ninit           2 7 33640\nkill           2 8 33096\nln             2 9 32912\nls             2 10 36280\nmkdir          2 11 33152\nrm             2 12 33144\nsh             2 13 54720\nstressfs       2 14 34040\nusertests      2 15 179344\ngrind          2 16 49392\nwc             2 17 35216\nzombie         2 18 32520\nhello-world    2 19 32656\nconsole        3 20 0\n</code></pre> <p>We can check there is a hello-world program. Then we can execute it by: <pre><code>$ hello-world\nHello, world!\n</code></pre></p> <p>What happened? The code after <code>exit(0)</code> is just ignored. The reason for this is the program just exits at <code>exit(0)</code> and of course the left code wouldn't be executed forever. </p> <p>Ok, now let's just see what will happend in the call of <code>exit(0)</code>. </p> <p>The definition of <code>exit()</code> function is in the file <code>/user/user.h</code>.</p> <pre><code>...\n// system calls\nint fork(void);\nint exit(int) __attribute__((noreturn));\nint wait(int*);\n...\n</code></pre> <p>We can see that its return value is an integer and it receives an inteter as its parameter. The <code>__attribute__((noreturn))</code> part is a compiler annotation telling the compilers (gcc &amp; clang both support this) this function wouldn't return. </p> <p>However, this is just the definition of this function. In C/C++, we know that a definition of function isn't executable. Therefore, where is the implementation of this function?</p> <p>The secret is in the file <code>/user/usys.pl</code>. This file is a Perl program. Perl is just like Python, which is also an interpreter-based language. </p> <p>This <code>usys.pl</code> would generate the 'trigger' for function calls. This Perl script might be dense, but once you compile xv6 using <code>make qemu</code>, you can find the file generated by it, which is <code>/user/usys.S</code>. </p> <pre><code># generated by usys.pl - do not edit\n#include \"kernel/syscall.h\"\n...\n.global exit\nexit:\n li a7, SYS_exit\n ecall\n ret\n...\n</code></pre> <p>Generally, this <code>/user/usys.S</code>, which is an assembly code for RISC-V, has done two things-including <code>/kernel/syscall.h</code> and making many global symbols (declared by <code>.global **</code>, e.g., <code>.global exit</code> defines a symbol <code>exit</code>) with corresponding functions' assembly code.</p> <p>Let's just use the example of <code>exit()</code>.</p> <pre><code>.global exit        # declare a symbol, you can image it as a variable\nexit:               # this is a tag, meaning symbol exit points to here\n li a7, SYS_exit    # load immediate value, SYS_exit, into register a7\n ecall              # system call instruction in RISC-V\n ret                # return\n</code></pre> <p>There are still several questions in this small piece of assembly code.</p> <ol> <li>Where is the immediate value <code>SYS_exit</code>?</li> <li>Where does the program go after we use <code>ecall</code> function?</li> </ol> <p>For the first question, let's get back to the first thing <code>usys.S</code> has done-the included file <code>/kernel/syscall.h</code></p> <pre><code>// System call numbers\n#define SYS_fork    1\n#define SYS_exit    2\n#define SYS_wait    3\n...\n</code></pre> <p>See? All the immediate values are define here and included into the assembly code by <code>#include \"kernel/syscall.h\"</code>. </p> <p>For the second question, it's a little complicated. If you want to learn more, you can refer to xv6 book chapter 4.3. In short, <code>ecall</code> instruction in user mode (now we are running <code>hello-world</code>, which is a userspace program) will trap the execution into <code>uservec()</code> function in <code>trampoline.S</code> and further get into <code>usertrap()</code> function in <code>/kernel/trap.c</code>. </p> <p>So far, the transition between user space and kernel space has done. The CPU's privilege mode has been set to 1, which is supervisor mode (S-mode). However, the memory page table hasn't been set to kernel's (you can think about the reason after you learn more). </p> <pre><code>void\nusertrap(void)\n{\n...\n    intr_on();\n\n    syscall();\n} else if((which_dev = devintr()) != 0){\n...\n}\n</code></pre> <p>Following function <code>usertrap()</code> in <code>/kernel/trap.c</code>, it finally goes to <code>syscall(void)</code> function in <code>/kernel/syscall.c</code>. This function is easy to understand now (T.T compared to previous assembly code). </p> <pre><code>void\nsyscall(void)\n{\n    int num;\n    struct proc *p = myproc();\n\n    num = p-&gt;trapframe-&gt;a7;\n    if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {\n        // Use num to lookup the system call function for num, call it,\n        // and store its return value in p-&gt;trapframe-&gt;a0\n        p-&gt;trapframe-&gt;a0 = syscalls[num]();\n    } else {\n        printf(\"%d %s: unknown sys call %d\\n\",\n                        p-&gt;pid, p-&gt;name, num);\n        p-&gt;trapframe-&gt;a0 = -1;\n    }\n}\n</code></pre> <p>At line 137, we got the number stored in user program's register <code>a7</code>. Feel familiar? Yes! It was stored a little before in the function <code>exit()</code> of <code>/user/usys.S</code>.</p> <pre><code>.global exit        # declare a symbol, you can image it as a variable\nexit:               # this is a tag, meaning symbol exit points to here\n li a7, SYS_exit    # load immediate value, SYS_exit, into register a7 HERE!!!!!!!!!\n ecall              # system call instruction in RISC-V\n ret                # return\n</code></pre> <p><code>SYS_exit</code>, which is just the SYSTEM CALL NUMBER, was stored in user program and then read by kernel here. Magic, right?</p> <p>Then there is a <code>if</code> statement judging whetehr the syscall number is greater than 0 and less than the number of elements in <code>syscalls</code> table. OK, now let's take a look at <code>syscalls</code> table. (It's from line 107 - 129)</p> <pre><code>// An array mapping syscall numbers from syscall.h\n// to the function that handles the system call.\nstatic uint64 (*syscalls[])(void) = {\n[SYS_fork]    sys_fork,\n[SYS_exit]    sys_exit,\n...\n};\n</code></pre> <p>Here, this type might be hard to understand. To be simple, it's an array and each element in this array is a function pointer. The functions should have type of <code>uint64 function(void)</code>, which means these functions receive no arguments and return a single unsigned 64-bits integer. </p> <p>Then, what's the values in this array? Let's use a simple C program example.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int arr[] = {\n        [0] 10,\n        [1] 100,\n        [3] 1000,\n        [5] 0xdeadbeef\n    };\n\n    int len = sizeof(arr) / sizeof(int);\n    printf(\"Length of arr: %d\\n\", len);\n    for (int i = 0; i &lt; len; ++i) {\n        printf(\"arr[%d] = %d\\n\", i, arr[i]);\n    }\n}\n</code></pre> <p>You can simply copy this code and run it on your computer. The result should be: <pre><code>$ ./main\nLength of arr: 6\narr[0] = 10\narr[1] = 100\narr[2] = 0\narr[3] = 1000\narr[4] = 0\narr[5] = -559038737\n</code></pre></p> <p>Now, it's pretty obvious! The numbers in <code>[]</code> is the index and the number after each index is it's corresponding value. For example, we stored 10 to position 0 and 1000 to position 3. </p> <p>Note: this semantic isn't officially supported by C++, which means even it's a valid grammer in C, it might be failed in compilation for some C++ compilers. </p> <p>Now, let's come back to the <code>syscalls</code> array. There are some functions and each function is stored at the position of its system call number. For example, the syscall number for <code>exit()</code> is 2, which you can find in <code>/kernel/syscall.h</code>. Therefore <code>syscalls[2]</code> will be a function pointer pointing to <code>sys_exit()</code>. </p> <p>We are close!</p> <p>Then, what is <code>sys_exit()</code>? It's in file <code>/kernel/sysproc.c</code> and you can find it's pretty short. But before we get into the implementation of the function, we should know how can an array in <code>/kernel/syscall.c</code> use a function defined in <code>/kernel/sysproc.c</code>. If we want to use functions from another file, we typically define it in a header file and implement it in a source file. Whenever we want to use it, include the header file and call it. During the compilcation, we just need to pass these two source files to the compiler, it will find the function and link them. But... the situation here is a little different. As there is no header file defining the <code>sys_**</code> functions, functions in <code>/kernel/syscall.c</code> cannot find them. So, if you pay attention to the code just before the <code>syscalls[]</code> table, you will see there are a lot of <code>sys_**</code> functions defined as extern function. The key word <code>extern</code> tells the compiler, \"this function's implementation is not here, but it will be somewhere else. I will give the source file including this function to you later. Now, you just assume you have already had the implemetation of this function. \" </p> <p>Good? To learn more about <code>extern</code> key word, you can refer this stack overflow thread. </p> <p>Now let's get into the implementation of <code>sys_exit()</code>.</p> <pre><code>uint64\nsys_exit(void)\n{\n    int n;\n    argint(0, &amp;n);\n    exit(n);\n    return 0;  // not reached\n}\n</code></pre> <p>Do you still remember what the definition of <code>exit()</code> syscall is in the user space? It's <code>int exit(int) __attribute__((noreturn))</code>. It has one argument and one return value, both are of integer type. But now, when coming to <code>sys_exit()</code>, the return value is still there, but where is our argument?</p> <p>Here, we need to explain why we cannot directly pass our parameters using our normal way (i.e., <code>sys_exit(int)</code>). It is because when we stores the function pointers to <code>syscalls[]</code>, all functions should have the same type. However, different system call has their own type of parameters. Hence, for a more convenient call of system calls of different arguments type, we make all of them with non-argument and let them parse their own arguments in <code>sys_**()</code>. (No matter you understand or not, I'm confused now :( )</p> <p>In the first line of the function, it prepare a value <code>n</code> for the argument passed for <code>exit()</code> syscall. <code>argint(0, &amp;n)</code> fetches the first value in the calling argument and stores it into variable <code>n</code>. Then it execute <code>exit(n)</code>. (Can it be the last function containing <code>exit</code>????)</p> <p>OK, now let's see the very LAST <code>exit()</code> function. It's in the file <code>/kernel/proc.c</code>. However, before we step into the actual function implementation, we need know how <code>sys_exit()</code> finds <code>exit()</code> first. These two functions are defined in two differen  files, in order for one to find another, there should be a \"bridge\" for them. As we mentioned before, the most common bridge is a header file. Here, the same, there is a header file storing all definition of kernel functions (just like <code>/user/user.h</code>), which is <code>/kernel/defs.h</code>. You can also find it by doing a small search about the function definitions. </p> <p>Searching, finding where the definition and implementation is a very important skill in C/C++ programming. The documentation is sometimes (tbh, always) unreliable. Therefore, most of time you need to learn from the code by yourself. Currently, the C/C++ extension in VSCode is very powerful and you can tack the function call flow by simply using <code>ctrl + left click</code> (or <code>command + left click</code> on macOS). However, sometimes it may skip some definition. Therefore, search and filter by yourself is most reliable way. </p> <pre><code>// Exit the current process.  Does not return.\n// An exited process remains in the zombie state\n// until its parent calls wait().\nvoid\nexit(int status)\n{\n    struct proc *p = myproc();\n\n    if(p == initproc)\n        panic(\"init exiting\");\n\n    // Close all open files.\n    for(int fd = 0; fd &lt; NOFILE; fd++){\n        if(p-&gt;ofile[fd]){\n            struct file *f = p-&gt;ofile[fd];\n            fileclose(f);\n            p-&gt;ofile[fd] = 0;\n        }\n    }\n\n    begin_op();\n    iput(p-&gt;cwd);\n    end_op();\n    p-&gt;cwd = 0;\n\n    acquire(&amp;wait_lock);\n\n    // Give any children to init.\n    reparent(p);\n\n    // Parent might be sleeping in wait().\n    wakeup(p-&gt;parent);\n\n    acquire(&amp;p-&gt;lock);\n\n    p-&gt;xstate = status;\n    p-&gt;state = ZOMBIE;\n\n    release(&amp;wait_lock);\n\n    // Jump into the scheduler, never to return.\n    sched();\n    panic(\"zombie exit\");\n}\n</code></pre> <p>This function is well documented so I wouldn't write a lot to explain it. But we can see, in the end, it calls <code>sched()</code> which is the process scheduler. When it gets into the scheduler, the other ready processes will be run by the scheduler. </p> <p>So, question is, where is our argument, the status for exit? It is stored in <code>p-&gt;xstate</code>, which is used for storing the exit status specially. </p> <p>I wrote all of this by my own. Hopefully it can help you understand how function call works. T_T</p>"},{"location":"lab-instructions/lab1/#your-task","title":"Your Task","text":"<p>There is only one task for you, easy, not much work to do and only a few dozen lines of code could finish it. </p> <p>Now, you may (or may not) know that, <code>fork()</code> will create a child process. Now, suppose you have one parent process with PID=1 and two child processes of him, PID=2 and PID=3. What if your parent want to wait for these two child processes finishing their work?</p> <p>You can use <code>wait()</code> syscall. <code>wait()</code> will return once there is one child process exits (in another word, becomes zombie as we saw in <code>exit()</code>) after cleaning up all the memory for the child process. </p> <p>Easy to understand, right?</p> <p>Your task, is adding another system call with user space definition</p> <pre><code>int waitpid(int *status, int pid, int options);\n</code></pre> <p>Explanation for parameters:</p> <ol> <li><code>int *status</code>, this is a pointer, the status of exited program should be stored into this location, just like <code>wait(int*)</code>. </li> <li><code>int pid</code>, instead of waiting for arbitrary child process terminating, <code>waitpid()</code> should only wait for specific child with <code>pid</code>. To be more specific:<ol> <li>If pid &lt;= 0, which means it's an invalid pid in xv6 (xv6 has a pid &gt; 0), your function should work as <code>wait(int*)</code>, which means it will return whenever a child process exits. </li> <li>If pid &gt; 0, but the process with <code>pid</code> isn't the child of current process, your function should return -1. </li> <li>If pid &gt; 0 and the process with <code>pid</code> is the child of current process, but the child process with <code>pid</code> isn't running, your funcion should return -1.</li> <li>If pid &gt; 0 and the process with <code>pid</code> is the child of current process, the child process is running at the same time, your function should wait until its status becomes <code>zombie</code>. Then, clean up the memory the child process is using (just like in <code>wait()</code>) and return the status of the child process. </li> </ol> </li> <li><code>options</code>, we'd play something in the function for this options. The <code>options</code> in Linux kernel is complex and it defines many macro for different function (you can take a look from here). We don't need that complex <code>options</code>. Instead, we'd just use several values to change the operation of the function.<ol> <li>If <code>options == 0</code> just run as normal (do nothing extra).</li> <li>If <code>options == 1</code>, use <code>printf()</code> (you may be curious about this <code>printf()</code>, this <code>printf()</code> is different from the one we used in normal program, this one is defined under the kernel space of xv6, even though they have the same function.) to output a line of <code>OPTIONS=1</code> and a new line character <code>\\n</code>. Then your function should do nothing and return 0.</li> <li>If <code>options == 2</code>, do as normal, but when you store the status code of the child process, don't use the exact one, use a fake one <code>0x33</code> and the other things should be the same. </li> <li>If <code>options == 3</code>, do nothing and return immediately with return value -1. </li> </ol> </li> </ol>"},{"location":"lab-instructions/lab1/#step-by-step-instruction","title":"Step-by-Step Instruction","text":"<p>Attention: as C program compilation is very flexible, it's not necessary for you to following the instruction so strictly. You can design, create, define and implement the function as you wish as long as it can work properly. If you aren't familiar to C programming or you haven't understand the background very well, you can start Lab 1 by just following the instructions here. </p> <p>So, following our mind in the background, let's start from user space. </p> <p>The first thing is adding a definition for our syscall in user space. It's inside the file <code>/user/user.h</code>. </p> <p>Don't understand the different between header file (.h file) and source file (.c)? Take a look at here (from UAA). </p> <p>Take a look at our required user space definition for the system call and finish this part. </p> <p>The second thing is adding the syscall's implementation under user space. Now, take a little review in background, where is the syscalls' implementation in user space?</p> <p>Remember that Perl script and generated assembly code? Yes, it's in <code>/user/usys.S</code>. However, this file is not written directly by us, instead it's generated by the Perl script. Don't worry if you don't understand the Perl script. Take a look at the script file <code>/user/usys.pl</code> and it's not hard to understand, right? The script sets a subroutine <code>entry</code> and it will print the corresponding entry assembly code for each syscalls defined here. Therefore, in order to add our <code>waitpid()</code> syscall, we need to add an entry here as well. </p> <p>OK, now you may have noticed that, in <code>/user/usys.pl</code>, it includes a file <code>/kernel/syscall.h</code> and it uses variable <code>SYS_${name}</code> defined in it. We have seen this file before and there are several system calls and its syscall number defined. So, pick up a desirable system call number and define it in <code>/kernel/syscall.h</code>. </p> <p>There are 21 system calls defined in xv6 and they have consecutive syscall numbers. It's natural for us picking a number 22 for our <code>waitpid()</code> syscall. But, is it really necessary? Can I choose other numbers here and what's the influence if I choose a very large number? If you cannot come up with an answer, remind yourself a little about the <code>syscalls[]</code> array we described in the background. </p> <p>As you may notice, we are in the kernel level now. So, what is next step? It looks like all the clues stop here. </p> <p>It's the time to review how a system call is triggered by the kernel-the trap, right? There is a trap file and it calls something related to <code>syscall()</code> (if you don't remember, just go back to the background). </p> <p>Let go to <code>usertrap()</code> function and it seems there is nothing we can do here and it will finally get into function <code>syscall()</code> in <code>/kernel/syscall.c</code>. Here, we notice a old friend, the <code>syscalls[]</code> table, right? We have defined our syscall numbers in <code>/kernel/syscall.h</code>, therefore we have already had a constant number variable with name <code>SYS_**</code> corresponding to our syscall and here, we need to associate the syscall number with a concrete system call function, just like the association between the number <code>SYS_exit</code> (i.e., this number is 2 as we find in <code>syscall.h</code>) and <code>sys_exit()</code> function. </p> <p>OK, we make a connection between them, but wait, where is our system call function? </p> <p>Firstly, there are some <code>extern</code> function defined just before this <code>syscalls[]</code> table, in order for our table can find the function, we should define an extern function corresponding to our <code>waitpid()</code> syscall here as well. </p> <p>Then, let's find where <code>sys_exit()</code> is and it's in the file <code>/kernel/sysproc.c</code>. Do you remember, here, the <code>sys_exit()</code> prepare the arguments for the real <code>exit()</code> function. Similarly, we need to define a function here preparing arguments for the real <code>waitpid()</code> function. </p> <p>Emmm... but the question is, we can learn from <code>sys_exit()</code> that if we want to fetch a integer from the argument, we need to use <code>argint()</code>. We have <code>pid</code> and <code>option</code> in integer, but how can I fetch a type <code>int*</code> for the argument? Don't worry, do you still remember <code>wait(int* status)</code> function call? There is a pointer as well! So, take a look at that function and you can find what you need. </p> <p>Then, just finish this part by yourself. </p> <p>Now, we come to the most challenge part in the Lab and you need to implement the most of your code here, by yourself. We can follow the <code>sys_exit()</code> and it will call <code>exit(int)</code> in <code>/kernel/proc.c</code>. Similarly, you can define your <code>waitpid()</code> function here. </p> <p>But stop for a minute. Do you still remember, in order to let <code>sys_exit()</code> find <code>exit()</code>, there is a definition for <code>exit()</code> in <code>/kernel/defs.h</code> and it is included in <code>/kernel/sysproc.c</code>. Therefore, make a definition for our <code>waitpid()</code> in <code>/kernel/defs.h</code> so that our <code>sys_waitpid()</code> could find the definition for this function. </p> <p>Then, what to do? The most intuitive thing is that you can copy the code from <code>wait(int*)</code> function as they perform two similar things. Now, it's time to take a look at your tasks and implement it according to the requirements. </p> <p>If you meet any confusion during finishing the Lab, don't hesitate to ask! It might be my bad. Maybe I made an unreasonable requirement or I miss something in the code. </p>"},{"location":"lab-instructions/lab1/#grading-policy","title":"Grading Policy","text":"<p>10 pts in total:</p> <ol> <li>2 pts for the attendance. </li> <li>8 pts for the Lab code (as shown in autograder if you submit your report). If you don't have a report submitted, your grade for the code will receive a 50% penalty. </li> </ol> <p>We reserve the rights to grade your Lab according to your report in any situation. You can make a request for grading your Lab just according to your report if you cannot submit a runnable code. But we can't ensure we will give you any grade. </p> <p>We may also grade your assignment just according to your report (which means we will give up your grade in autograder) if we find any SENSITIVE code in your work or we find some unmatch performance for you between the labs and lectures. To avoid this case, understand and following the instruction well, write the code by yourself and never share your code with others. </p>"},{"location":"lab-instructions/lab1/#what-to-write-in-report","title":"What to write in report","text":"<p>We don't expect a very detailed report. Keep it in 2-3 pages. You don't need to copy, paste and explain your code in the report, as we can find them in your repo. </p> <p>Instead, you need to explain</p> <ol> <li>Which files you modified and the reason for the modification. </li> <li>Is there any difficulty you met and how do you solve them. </li> <li>If let you pick some special functions for more options, what will you choose and do you have some reality reason for this choice. (e.g., there are many options for <code>waitpid()</code> in the real world Linux and they all have their corresponding existing reasons). </li> </ol> <p>You can add other things in the report as well if you like. </p>"}]}