# Lab 1 - System Call

## Background

### What is system call?

A system call is a way for programs to interact with the operating system. It provides an interface between a process and the operating system, allowing the process to request high-privilege services such as file operatios, process control and communication. 

Because it involves two parties - the user program (low privilege) and the operating system (high privilege), it is bound to have a transition of privileges. 

### How does system call work?

You can call a system call (e.g., exit(), which is used for terminating current program) in a user space program (like in our hello-world.c program). Let's just use our hello-world program and change it a little bit.

```c
// hello-world.c in /user/
#include "kernel/types.h"
#include "user/user.h"

int main(int argc, char **argv) {
    printf("Hello, world!\n");
    exit(0);
    printf("?.? Dead code ?.?\n");
}
```

Also, we need to add a line in the `Makefile`. This modification adds a user space program, making program `make` know that it should compile the program `hello-world.c` under `/user/`. `$U` stands for `/user/` directory. 

```makefile
... line 138
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_hello-world\
```

Let's compile this file and see what will happen. 

```bash
$ make qemu
riscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S
...
xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$ 
```

Then use `ls` command listing all available programs in user space. 

```bash
$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2292
cat            2 3 34256
echo           2 4 33184
forktest       2 5 16168
grep           2 6 37520
init           2 7 33640
kill           2 8 33096
ln             2 9 32912
ls             2 10 36280
mkdir          2 11 33152
rm             2 12 33144
sh             2 13 54720
stressfs       2 14 34040
usertests      2 15 179344
grind          2 16 49392
wc             2 17 35216
zombie         2 18 32520
hello-world    2 19 32656
console        3 20 0
```

We can check there is a hello-world program. Then we can execute it by:
```bash
$ hello-world
Hello, world!
```

What happened? The code after `exit(0)` is just ignored. The reason for this is the program just exits at `exit(0)` and of course the left code wouldn't be executed forever. 

Ok, now let's just see what will happend in the call of `exit(0)`. 

The definition of `exit()` function is in the file `/user/user.h`.

```c
...
// system calls
int fork(void);
int exit(int) __attribute__((noreturn));
int wait(int*);
...
```

We can see that its return value is an integer and it receives an inteter as its parameter. The `__attribute__((noreturn))` part is a compiler annotation telling the compilers (gcc & clang both support this) this function wouldn't return. 

However, this is just the definition of this function. In C/C++, we know that a definition of function isn't executable. Therefore, where is the implementation of this function?

The secret is in the file `/user/usys.pl`. This file is a Perl program. Perl is just like Python, which is also an interpreter-based language. 

This `usys.pl` would generate the 'trigger' for function calls. This Perl script might be dense, but once you compile xv6 using `make qemu`, you can find the file generated by it, which is `/user/usys.S`. 

```asm
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
...
.global exit
exit:
 li a7, SYS_exit
 ecall
 ret
...
```

Generally, this `/user/usys.S`, which is an assembly code for RISC-V, has done two things-including `/kernel/syscall.h` and making many global symbols (declared by `.global **`, e.g., `.global exit` defines a symbol `exit`) with corresponding functions' assembly code.

Let's just use the example of `exit()`.

```asm
.global exit        # declare a symbol, you can image it as a variable
exit:               # this is a tag, meaning symbol exit points to here
 li a7, SYS_exit    # load immediate value, SYS_exit, into register a7
 ecall              # system call instruction in RISC-V
 ret                # return
```

There are still several questions in this *small* piece of assembly code.

1. Where is the immediate value `SYS_exit`?
2. Where does the program go after we use `ecall` function?

For the first question, let's get back to the first thing `usys.S` has done-the included file `/kernel/syscall.h`

```c
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
...
```

See? All the immediate values are define here and included into the assembly code by `#include "kernel/syscall.h"`. 

For the second question, it's a little complicated. If you want to learn more, you can refer to [xv6 book](https://pdos.csail.mit.edu/6.1810/2024/xv6/book-riscv-rev4.pdf) chapter 4.3. In short, `ecall` instruction in user mode (now we are running `hello-world`, which is a userspace program) will trap the execution into `uservec()` function in `trampoline.S` and further get into `usertrap()` function in `/kernel/trap.c`. 

So far, the transition between user space and kernel space has done. The CPU's privilege mode has been set to 1, which is supervisor mode (S-mode). However, the memory page table hasn't been set to kernel's (you can think about the reason after you learn more). 

```c
void
usertrap(void)
{
...
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
...
}
```

Following function `usertrap()` in `/kernel/trap.c`, it finally goes to `syscall(void)` function in `/kernel/syscall.c`. This function is easy to understand now (T.T compared to previous assembly code). 

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    // Use num to lookup the system call function for num, call it,
    // and store its return value in p->trapframe->a0
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

At line 137, we got the number stored in user program's register `a7`. Feel familiar? Yes! It was stored a little before in the function `exit()` of `/user/usys.S`.

```asm
.global exit        # declare a symbol, you can image it as a variable
exit:               # this is a tag, meaning symbol exit points to here
 li a7, SYS_exit    # load immediate value, SYS_exit, into register a7 HERE!!!!!!!!!
 ecall              # system call instruction in RISC-V
 ret                # return
```

`SYS_exit`, which is just the SYSTEM CALL NUMBER, was stored in user program and then read by kernel here. Magic, right?

Then there is a `if` statement judging whetehr the syscall number is greater than 0 and less than the number of elements in `syscalls` table. OK, now let's take a look at `syscalls` table. (It's from line 107 - 129)

```c
// An array mapping syscall numbers from syscall.h
// to the function that handles the system call.
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
...
};
```

Here, this type might be hard to understand. To be simple, it's an array and each element in this array is a [*function pointer*](https://www.geeksforgeeks.org/function-pointer-in-c/). The functions should have type of `uint64 function(void)`, which means these functions receive no arguments and return a single unsigned 64-bits integer. 

Then, what's the values in this array? Let's use a simple C program example.

```c
#include <stdio.h>

int main() {
    int arr[] = {
        [0] 10,
        [1] 100,
        [3] 1000,
        [5] 0xdeadbeef
    };

    int len = sizeof(arr) / sizeof(int);
    printf("Length of arr: %d\n", len);
    for (int i = 0; i < len; ++i) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
}
```

You can simply copy this code and run it on your computer. The result should be:
```bash
$ ./main
Length of arr: 6
arr[0] = 10
arr[1] = 100
arr[2] = 0
arr[3] = 1000
arr[4] = 0
arr[5] = -559038737
```

Now, it's pretty obvious! The numbers in `[]` is the index and the number after each index is it's corresponding value. For example, we stored 10 to position 0 and 1000 to position 3. 

> Note: this semantic isn't officially supported by C++, which means even it's a valid grammer in C, it might be failed in compilation for some C++ compilers. 

Now, let's come back to the `syscalls` array. There are some functions and each function is stored at the position of its system call number. For example, the syscall number for `exit()` is 2, which you can find in `/kernel/syscall.h`. Therefore `syscalls[2]` will be a function pointer pointing to `sys_exit()`. 

We are close!

Then, what is `sys_exit()`? It's in file `/kernel/sysproc.c` and you can find it's pretty short. 

```c
uint64
sys_exit(void)
{
  int n;
  argint(0, &n);
  exit(n);
  return 0;  // not reached
}
```

Do you still remember what the definition of `exit()` syscall is in the user space? It's `int exit(int) __attribute__((noreturn))`. It has one argument and one return value, both are of integer type. But now, when coming to `sys_exit()`, the return value is still there, but where is our argument?

Here, we need to explain why we cannot directly pass our parameters using our normal way (i.e., `sys_exit(int)`). It is because when we stores the function pointers to `syscalls[]`, all functions should have the same type. However, different system call has their own type of parameters. Hence, for a more convenient call of system calls of different arguments type, we make all of them with non-argument and let them parse their own arguments in `sys_**()`. (No matter you understand or not, I'm confused now :( )

In the first line of the function, it prepare a value `n` for the argument passed for `exit()` syscall. `argint(0, &n)` fetches the first value in the calling argument and stores it into variable `n`. Then it execute `exit(n)`. (Can it be the last function containing `exit`????)

OK, now let's see the very LAST `exit()` function. It's in the file `/kernel/proc.c`. 

```c
// Exit the current process.  Does not return.
// An exited process remains in the zombie state
// until its parent calls wait().
void
exit(int status)
{
  struct proc *p = myproc();

  if(p == initproc)
    panic("init exiting");

  // Close all open files.
  for(int fd = 0; fd < NOFILE; fd++){
    if(p->ofile[fd]){
      struct file *f = p->ofile[fd];
      fileclose(f);
      p->ofile[fd] = 0;
    }
  }

  begin_op();
  iput(p->cwd);
  end_op();
  p->cwd = 0;

  acquire(&wait_lock);

  // Give any children to init.
  reparent(p);

  // Parent might be sleeping in wait().
  wakeup(p->parent);
  
  acquire(&p->lock);

  p->xstate = status;
  p->state = ZOMBIE;

  release(&wait_lock);

  // Jump into the scheduler, never to return.
  sched();
  panic("zombie exit");
}
```

This function is well documented so I wouldn't write a lot to explain it. But we can see, in the end, it calls `sched()` which is the process scheduler. When it gets into the scheduler, the other ready processes will be run by the scheduler. 

So, question is, where is our argument, the status for exit? It is stored in `p->xstate`, which is used for storing the exit status specially. 

> I wrote all of this by my own. Hopefully it can help you understand how function call works. T_T

## Your Task

There is only one task for you, easy, not much work to do and only a few dozen lines of code could finish it. 

Now, you may (or may not) know that, `fork()` will create a child process. Now, suppose you have one parent process with PID=1 and two child processes of him, PID=2 and PID=3. What if your parent want to wait for these two child processes finishing their work?

You can use `wait()` syscall. `wait()` will return once there is one child process exits (in another word, becomes *zombie* as we saw in `exit()`) after cleaning up all the memory for the child process. 

Easy to understand, right?

Your task, is adding another system call with user space definition

```c
int waitpid(int *status, int pid, int option);
```

Explanation for parameters:

1. `int *status`, this is a pointer, the status of exited program should be stored into this location, just like `wait(int*)`. 
2. `int pid`, instead of waiting for arbitrary child process terminating, `waitpid()` should only wait for specific child with `pid`. There are some special values for it:
   1. If pid <= 0, which means it's an invalid pid in xv6 (xv6 has a pid > 0), your function should work as `wait(int*)`, which means it will return whenever a child process exits. 
   2. If pid > 0, but the process with pid isn't 
3. 

